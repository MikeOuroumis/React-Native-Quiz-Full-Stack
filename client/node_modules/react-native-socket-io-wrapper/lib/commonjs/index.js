"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactNative = require("react-native");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SocketIO {
  constructor(url, options) {
    _defineProperty(this, "SocketIOModule", void 0);

    _defineProperty(this, "SocketIOCallbacksList", void 0);

    _defineProperty(this, "eventEmitter", void 0);

    _defineProperty(this, "path", void 0);

    _defineProperty(this, "options", void 0);

    this.SocketIOModule = _reactNative.NativeModules.RNSocketIO;
    this.SocketIOCallbacksList = {};
    this.path = (options === null || options === void 0 ? void 0 : options.path) || '/socket.io';
    this.options = { ...options,
      path: this.path
    };
    this.eventEmitter = new _reactNative.NativeEventEmitter(_reactNative.NativeModules.SocketIo);
    this.eventEmitter.addListener('onEventListener', nativeEvent => {
      var _this$SocketIOCallbac;

      (_this$SocketIOCallbac = this.SocketIOCallbacksList[nativeEvent.uniqueID]) === null || _this$SocketIOCallbac === void 0 ? void 0 : _this$SocketIOCallbac.callback(nativeEvent.data);
    });
    this.SocketIOModule.initialize(url, this.options, this._callCallbackResponse);
  }

  _callCallbackResponse(error) {
    if (error) {
      throw error;
    }
  }
  /**
   * Open socket connection.
   */


  connect() {
    this.SocketIOModule.connect(this.path);
  }
  /**
   * Close socket connection.
   */


  disconnect() {
    this.SocketIOModule.disconnect(this.path);
  }
  /**
   * Send socket event.
   * @param eventName Name of socket event.
   * @param data Data to send on socket event.
   */


  emit(eventName, data) {
    this.SocketIOModule.emit(this.path, eventName, {
      data
    });
  }
  /**
   * Listen to socket event.
   * @param eventName Name of socket event.
   * @param callback Callback to listen to socket event.
   */


  on(eventName, callback) {
    this.SocketIOModule.on(this.path, eventName, (nativeEventName, uniqueID) => {
      this.SocketIOCallbacksList[uniqueID] = {
        uniqueID,
        eventName: nativeEventName,
        callback
      };
    });
  }
  /**
   * Listen once to socket event.
   * @param eventName Name of socket event.
   * @param callback Callback to listen to socket event.
   */


  once(eventName, callback) {
    this.SocketIOModule.once(this.path, eventName, (nativeEventName, uniqueID) => {
      this.SocketIOCallbacksList[uniqueID] = {
        uniqueID,
        eventName: nativeEventName,
        callback
      };
    });
  }
  /**
   * Remove socket event listener.
   * @param eventName Name of socket event.
   * @param callback Callback of registered socket event.
   */


  off(eventName, callback) {
    let keyToDelete = null;

    for (const key of Object.keys(this.SocketIOCallbacksList)) {
      const listItem = this.SocketIOCallbacksList[key];

      if (listItem.eventName === eventName && listItem.callback === callback) {
        keyToDelete = listItem.uniqueID;
        this.SocketIOModule.off(this.path, eventName, keyToDelete);
        break;
      }
    }

    if (keyToDelete) {
      delete this.SocketIOCallbacksList[keyToDelete];
    }
  }
  /**
   * Get connection status of socket.
   * @param callback Callback with connection status of socket.
   */


  connected(callback) {
    this.SocketIOModule.connected(this.path, callback);
  }
  /**
   * Get id of socket.
   * @param callback Callback with id of socket.
   */


  getId(callback) {
    this.SocketIOModule.getId(this.path, callback);
  }
  /**
   * Get connection status of socket.
   * Warning: this method are synchronous blocking UI, use it carefully.
   */


  connectedSync() {
    return this.SocketIOModule.connectedSync(this.path);
  }
  /**
   * Get id of socket.
   * Warning: this method are synchronous blocking UI, use it carefully.
   */


  getIdSync() {
    return this.SocketIOModule.getIdSync(this.path);
  }
  /**
   * Update socket options, this updates general instances paths.
   * @param options
   * @param callback
   */


  updateSocketOptions(options, callback) {
    if (!options) throw new Error('options is a required property of type "SocketIOOptions"');
    this.SocketIOModule.updateSocketOptions(options, callback);
  }
  /**
   * Update socket options, this updates general instances paths.
   * Warning: this method are synchronous blocking UI, use it carefully.
   * @param options
   */


  updateSocketOptionsSync(options) {
    if (!options) throw new Error('options is a required property of type "SocketIOOptions"');
    this.SocketIOModule.updateSocketOptionsSync(options);
  }

  static serializeQuery(object) {
    let str = [];

    for (const p in object) if (object.hasOwnProperty(p)) {
      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(object[p]));
    }

    return str.join('&');
  }

}

var _default = SocketIO;
exports.default = _default;
//# sourceMappingURL=index.js.map